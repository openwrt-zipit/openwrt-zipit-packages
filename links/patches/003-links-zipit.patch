diff -rupN links-2.3pre1.orig/Makefile.am links-2.3pre1/Makefile.am
--- links-2.3pre1.orig/Makefile.am	2009-05-17 15:45:41.000000000 -0400
+++ links-2.3pre1/Makefile.am	2012-06-22 09:43:22.000000000 -0400
@@ -13,7 +13,7 @@ links_LDADD=atheos.o
 else
 endif
 
-links_SOURCES=af_unix.c auth.c beos.c bfu.c block.c bookmarks.c cache.c charsets.c connect.c cookies.c default.c dip.c directfb.c directfb_cursors.h dither.c dns.c drivers.c error.c file.c finger.c font_include.c framebuffer.c ftp.c gif.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c links_icon.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c x.c xbm.c links.h cfg.h os_dep.h os_depx.h setup.h codepage.h language.h codepage.inc entity.inc uni_7b.inc language.inc upcase.inc arrow.inc bits.h
+links_SOURCES=af_unix.c auth.c beos.c bfu.c block.c bookmarks.c cache.c charsets.c connect.c cookies.c default.c dip.c directfb.c directfb_cursors.h dither.c dns.c drivers.c error.c file.c finger.c font_include.c framebuffer.c ftp.c gif.c html.c html_gr.c html_r.c html_tbl.c http.c https.c img.c imgcache.c jpeg.c jsint.c kbd.c language.c links_icon.c listedit.c lru.c mailto.c main.c memory.c menu.c objreq.c os_dep.c pmshell.c png.c sched.c select.c session.c smb.c svgalib.c terminal.c tiff.c types.c url.c view.c view_gr.c x.c xbm.c links.h cfg.h os_dep.h os_depx.h setup.h codepage.h language.h codepage.inc entity.inc uni_7b.inc language.inc upcase.inc arrow.inc bits.h sdl.c
 
 dist-hook:
 #remove the symlinka:
diff -rupN links-2.3pre1.orig/configure.in links-2.3pre1/configure.in
--- links-2.3pre1.orig/configure.in	2011-06-26 19:47:52.000000000 -0400
+++ links-2.3pre1/configure.in	2012-06-22 09:38:04.000000000 -0400
@@ -470,7 +470,7 @@ AC_ARG_WITH(svgalib, [  --without-svgali
 AC_ARG_WITH(x, [  --without-x             compile without X Window System graphics driver],[if test "$withval" = no; then disable_x=yes; else disable_x=no; fi])
 AC_ARG_WITH(fb, [  --without-fb            compile without Linux Framebuffer graphics driver],[if test "$withval" = no; then disable_fb=yes; else disable_fb=no; fi])
 AC_ARG_WITH(directfb, [  --without-directfb      compile without DirectFB graphics driver],[if test "$withval" = no; then disable_directfb=yes; else disable_directfb=no; fi])
-dnl AC_ARG_WITH(sdl, [  --without-sdl           compile without SDL graphics driver],[if test "$withval" = no; then disable_sdl=yes; else disable_sdl=no; fi])
+AC_ARG_WITH(sdl, [  --without-sdl           compile without SDL graphics driver],[if test "$withval" = no; then disable_sdl=yes; else disable_sdl=no; fi])
 AC_ARG_WITH(pmshell, [  --without-pmshell       compile without PMShell graphics driver],[if test "$withval" = no; then disable_pmshell=yes; else disable_pmshell=no; fi])
 AC_ARG_WITH(atheos, [  --without-atheos        compile without Atheos graphics driver],[if test "$withval" = no; then disable_atheos=yes; else disable_atheos; fi])
 
@@ -541,25 +541,25 @@ if test "$disable_x" != yes ; then
 	fi
 fi
 
-dnl if test "$disable_sdl" != yes ; then
-dnl 	AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
-dnl 	if test "$SDL_CONFIG" != "no"; then
-dnl 	        AC_MSG_CHECKING(for SDL >= 1.2.0)
-dnl         	sdl_version="`$SDL_CONFIG --version`"
-dnl 		if expr "$sdl_version" \>= 1.2.0 >/dev/null; then
-dnl 			AC_MSG_RESULT(yes)
-dnl 			SDL_CFLAGS="`$SDL_CONFIG --cflags`"
-dnl 			SDL_LIBS="`$SDL_CONFIG --libs`"
-dnl 	           	AC_DEFINE(GRDRV_SDL)
-dnl         	   	drivers="$drivers SDL"
-dnl 			CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
-dnl 			AC_CHECK_LIB(Xext, XextAddDisplay)
-dnl 			LIBS="$SDL_LIBS $LIBS"
-dnl 		else
-dnl 			AC_MSG_RESULT(no)
-dnl 		fi
-dnl 	fi
-dnl fi
+if test "$disable_sdl" != yes ; then
+	AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
+	if test "$SDL_CONFIG" != "no"; then
+	        AC_MSG_CHECKING(for SDL >= 1.2.0)
+        	sdl_version="`$SDL_CONFIG --version`"
+		if expr "$sdl_version" \>= 1.2.0 >/dev/null; then
+			AC_MSG_RESULT(yes)
+			SDL_CFLAGS="`$SDL_CONFIG --cflags`"
+			SDL_LIBS="`$SDL_CONFIG --libs`"
+	           	AC_DEFINE(GRDRV_SDL)
+        	   	drivers="$drivers SDL"
+			CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
+			AC_CHECK_LIB(Xext, XextAddDisplay)
+			LIBS="$SDL_LIBS $LIBS"
+		else
+			AC_MSG_RESULT(no)
+		fi
+	fi
+fi
 
 if test "$disable_pmshell" != yes ; then
 	AC_CACHE_CHECK([for pmshell], ac_cv_have_pmshell,
diff -rupN links-2.3pre1.orig/default.c links-2.3pre1/default.c
--- links-2.3pre1.orig/default.c	2011-06-26 16:11:29.000000000 -0400
+++ links-2.3pre1/default.c	2012-06-22 09:35:57.000000000 -0400
@@ -140,10 +140,26 @@ unsigned char *p_arse_options(int argc, 
 	return "";
 }
 
+#if 1 /* ZIPIT_Z2 */
+/* Use off white for background on ZIPIT instead of ugly gray. */
+unsigned int default_bgcolor = 0xFFFFDD;
+
+unsigned char *parse_options(int argc, unsigned char *argv[])
+{
+	unsigned char *retval;
+	retval = p_arse_options(argc, argv, all_options);
+	default_bg_g.r = (default_bgcolor >> 16) & 0xFF;
+	default_bg_g.g = (default_bgcolor >>  8) & 0xFF;
+	default_bg_g.b = (default_bgcolor      ) & 0xFF;
+	return retval;
+}
+
+#else
 unsigned char *parse_options(int argc, unsigned char *argv[])
 {
 	return p_arse_options(argc, argv, all_options);
 }
+#endif
 
 unsigned char *get_token(unsigned char **line)
 {
@@ -426,6 +442,11 @@ void load_config_file(unsigned char *pre
 	return;
 	ok:
 	parse_config_file(config_file, c, all_options);
+#if 1 /* ZIPIT_Z2 */
+	default_bg_g.r = (default_bgcolor >> 16) & 0xFF;
+	default_bg_g.g = (default_bgcolor >>  8) & 0xFF;
+	default_bg_g.b = (default_bgcolor      ) & 0xFF;
+#endif
 	mem_free(c);
 	mem_free(config_file);
 }
@@ -1474,7 +1495,13 @@ struct rgb default_link = { 255, 255, 25
 struct rgb default_vlink = { 255, 255, 0, 0 };
 
 struct rgb default_fg_g = { 0, 0, 0, 0 };
+#if 1 /* ZIPIT_Z2 */
+/* Use off white for background on ZIPIT instead of ugly gray. */
+struct rgb default_bg_g = { 0xFF, 0xFF, 0xDD, 0 };
+//unsigned int default_bgcolor = 0xFFFFDD;
+#else
 struct rgb default_bg_g = { 192, 192, 192, 0 };
+#endif
 struct rgb default_link_g = { 0, 0, 255, 0 };
 struct rgb default_vlink_g = { 0, 0, 128, 0 };
 
@@ -1621,6 +1648,9 @@ struct option html_options[] = {
 	{1, gen_cmd, num_rd, num_wr, 0, 1, &dds.target_in_new_window, "html_target_in_new_window", "html-target-in-new-window"},
 	{1, gen_cmd, num_rd, num_wr, 0, 9, &dds.margin, "html_margin", "html-margin"},
 	{1, gen_cmd, num_rd, num_wr, 1, MAX_FONT_SIZE, &dds.font_size, "html_font_size", "html-user-font-size"},
+#if 1 /* ZIPIT_Z2 */
+	{1, gen_cmd, num_rd, num_wr, 0, 0xffffff, &default_bgcolor, "html_default_bgcolor", "html-default-bgcolor"},
+#endif
 	{0, NULL, NULL, NULL, 0, 0, NULL, NULL, NULL},
 };
 
diff -rupN links-2.3pre1.orig/sdl.c links-2.3pre1/sdl.c
--- links-2.3pre1.orig/sdl.c	1969-12-31 19:00:00.000000000 -0500
+++ links-2.3pre1/sdl.c	2012-06-22 09:35:58.000000000 -0400
@@ -0,0 +1,1016 @@
+/*sdl.c
+	-- SDL graphic driver for Links (version 0.1.2)
+
+    Copyright (C) 2004	Samuel Behan <sam(at)frida(dot)fri(dot)utc(dot)sk>
+
+    This driver is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation; either version 2
+    of the License, or (at your option) any later version.
+
+    This driver is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    ---
+    I've wrote this driver just as a proof of concept for using SDL library. I wanted
+    to use something easy, so i've decided for the world's best web browser :)
+
+    TODO & BUGS:
+	- keyboard input system doesn't handles all characters, because sdl ignores any
+		system mappings and provides something like `raw keyboard access'
+	- *_strip functions are possibly bad implemented, actualy i don't understand what
+		they should do, or better i'm too lazy to find it out :)
+	- video initialization is static only, nor parametrized !!!
+	- BUGBUG: aa-lib nor caca lib, dont display nicely - they actualy display nothing ;(
+			This needs to be fixed, becase links over aa-lib as that what i've been
+			dreaming of [ try set env SDL_VIDEODRIVER="aalib" ]
+	* resize does not works (fixed)
+	? sdl_set_title should possibly convert passed strings
+	...and many more, not found yet :)
+*/
+
+
+#include "cfg.h"
+
+#ifdef GRDRV_SDL
+
+#ifdef TEXT
+#undef TEXT
+#endif
+
+#include "links.h"
+#include <signal.h>
+/* #include "arrow.inc" */
+
+/*sdl inclusions*/
+#include <SDL.h>
+#include <SDL_gfxPrimitives.h>
+
+
+/* helper tools */
+/* FIXME: enabled debug mode */
+#undef DEBUG
+#ifdef DEBUG
+#include <assert.h>
+#define S_ASSERT(code)	assert((code))
+#define S_ON_DEBUG(code)	code
+#define S_ON_DEBUG_TRACE(str)	fprintf(stderr, "[%s:%s:%d] %s\n", __FILE__, __PRETTY_FUNCTION__, __LINE__, str);
+#else
+#define S_ASSERT(code)
+#define S_ON_DEBUG(code)
+#define S_ON_DEBUG_TRACE(str)
+#endif
+
+/* internal types */
+typedef unsigned char 		u_char_t;
+typedef unsigned short int	u_short_t;
+struct graphics_driver sdl_driver;
+
+/* keysyms */
+#include "sdl_data.inc"
+
+static struct t_sdl_driver_data {
+	u_char_t	*video_drv;		/* used video driver name */
+	SDL_VideoInfo	*video_info;		/* video informations */
+	SDL_Cursor	*cursor;		/* cursor */
+	int		event_timer;		/* event timer id */
+	struct {
+		long  int	flags;		/* video flags */
+		short int	width;
+		short int	height;
+		short int	depth;
+	} video;
+} sdl_data = {
+	NULL,
+	NULL,
+	NULL,
+	0,
+	{ 0, 0, 0, 0 },
+};
+#define sdl_VIDEO_WIDTH		sdl_DATA.video.width
+#define sdl_VIDEO_HEIGHT	sdl_DATA.video.height
+#define sdl_VIDEO_DEPTH		sdl_DATA.video.depth
+#define sdl_VIDEO_FLAGS		sdl_DATA.video.flags
+
+/* DRIVER DATA HELPERS */ 
+#define sdl_DATA		sdl_data
+#define sdl_DATA_FREE()		if(sdl_DATA.video_drv != NULL)	mem_free(sdl_DATA.video_drv);	\
+				if(sdl_DATA.video_info != NULL)	mem_free(sdl_DATA.video_info);
+struct t_sdl_device_data {
+	SDL_Surface 		*p_surf;		/* primary surface	*/
+	struct graphics_device	*g_dev;			/* draphic device	*/
+/*	SDL_Rect		u_rect;	*/		/* update rectangle	*/
+	short			u_pending;		/* update pending	*/
+};
+#define sdl_SURFACE(ptr)	(ptr)->p_surf
+#define sdl_GD(ptr)		(ptr)->g_dev
+#define sdl_URECT(ptr)		(ptr)->u_rect
+#define sdl_UPENDING(ptr)	(ptr)->u_pending
+
+/* HELPER FUNCTIONS */
+#define sdl_COLOR(col)			(((col) << 2) | 0x00)
+
+#define sdl_SETUP_TIMER(dev)		\
+		sdl_DATA.event_timer	= install_timer(20, sdl_catch_event, (dev))
+#define sdl_KILL_TIMER()		\
+		kill_timer(sdl_DATA.event_timer)
+
+/* event catch helpers */
+#define sdl_CATCH_EVENTS_NUM	3
+#define sdl_MOUSE_STATE(var_in, var_out, def)	\
+		if(var_in == SDL_BUTTON(SDL_BUTTON_LEFT))			\
+			var_out	|= B_LEFT;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_RIGHT))			\
+			var_out	|= B_RIGHT;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_MIDDLE))		\
+			var_out	|= B_MIDDLE;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_WHEELUP))		\
+			var_out	|= B_WHEELUP;					\
+		else if(var_in == SDL_BUTTON(SDL_BUTTON_WHEELDOWN))		\
+			var_out	|= B_WHEELDOWN;					\
+		else	var_out	= (def);
+
+
+
+/* tha event handler */
+static void sdl_catch_event(void *data)
+{
+    register int i = 0, ev_num	= 0;
+    register struct t_sdl_device_data *dev	= NULL;
+    SDL_Event events[sdl_CATCH_EVENTS_NUM];
+    u_short_t	fl	= 0;
+    /* speedup (BUGGY, not thread safe !?!) */
+    static u_short_t o_x = 0, o_y = 0, o_fl = 0;
+#ifdef ZIPIT_Z2
+    static int dead_key = 0;
+
+    //static FILE *fp = NULL;      
+#endif
+
+    SDL_PumpEvents();
+    ev_num	= SDL_PeepEvents(events, sdl_CATCH_EVENTS_NUM, SDL_GETEVENT, SDL_ALLEVENTS);
+/*
+    S_ON_DEBUG(fprintf(stderr, "event: received %d\n", ev_num); );
+*/  
+    S_ASSERT(ev_num != -1);
+    /* get dev data */
+    dev		= (struct t_sdl_device_data *) data;
+    for(i = 0; i < ev_num; i++)
+    {
+#define event events[i]
+	switch (event.type)
+	{
+/*	    case SDL_ACTIVEEVENT:	*/
+	    /* mouse motion */
+            case SDL_MOUSEMOTION:
+		/* mose btn state */
+	        S_ON_DEBUG_TRACE("event: mouse motion");
+		fl	= B_DRAG;
+		sdl_MOUSE_STATE(event.motion.state, fl, B_MOVE);
+		/* save som calls (SDL generates many similar events)	*/
+		if(event.motion.x == o_x && event.motion.y == o_y && fl == o_fl)
+			break;
+		/* call handler */
+		sdl_GD(dev)->mouse_handler(sdl_GD(dev), event.motion.x, event.motion.y, fl);
+		o_x	= event.motion.x;
+		o_y	= event.motion.y;
+		o_fl	= fl;
+                break;
+	    /* mouse click */
+	    case SDL_MOUSEBUTTONUP:
+            case SDL_MOUSEBUTTONDOWN:
+		if(event.type == SDL_MOUSEBUTTONDOWN)
+			fl	= B_DOWN;
+		else
+			fl	= B_UP;
+	        S_ON_DEBUG_TRACE("event: mouse click");
+/*		sdl_MOUSE_STATE(event.button.state, fl, fl);	*/
+		sdl_GD(dev)->mouse_handler(sdl_GD(dev), event.button.x, event.button.y, fl);
+		break;
+	    /* keyboard */
+	    case SDL_KEYUP:
+	        S_ON_DEBUG_TRACE("event: key up");
+		break;
+            case SDL_KEYDOWN:
+	       {	/*translate */
+			int		k	= 0;
+			int		key	= 0;
+/*
+*			//////////////////////////
+*			//FIXME: needs rework !!!
+*			//	-- sdl works at low-level ignoring any system keymappings
+*			//	i've no idea how to do it (easily):(
+*			//////////////////////////
+*/
+			S_ON_DEBUG_TRACE("event: key down");
+			while(sdl_keysyms[k].sym != event.key.keysym.sym && sdl_keysyms[k].sym != SDLK_LAST)
+				k++;
+			S_ASSERT(sdl_keysyms[k].sym != SDLK_LAST);
+			/* FIXME: hope nobody changes enumeration values in SDL libs */
+			if(sdl_keysyms[k].sym >= SDLK_NUMLOCK && sdl_keysyms[k].sym <= SDLK_COMPOSE) 
+				break;	/* aka ignore modifiers */
+#ifdef ZIPIT_Z2
+			//if (fp == NULL)
+			//  fp = fopen("/tmp/keylog.txt", "w");
+
+			/* key re-map */
+			key	= sdl_keysyms[k].key;
+			fl	= event.key.keysym.mod;
+			if((fl & KMOD_RALT) || (fl & KMOD_LALT)) /* (fl & KMOD_ALT) */
+			{
+			  if(fl & KMOD_SHIFT)
+			    key	= sdl_keysyms[k].sakey;
+			  else
+			    key	= sdl_keysyms[k].akey;
+			}
+			else if(fl & KMOD_SHIFT)
+			{
+			  if((fl & KMOD_RALT) || (fl & KMOD_LALT)) /* (fl & KMOD_ALT) */
+			    key	= sdl_keysyms[k].sakey;
+			  else
+			    key	= sdl_keysyms[k].skey;
+			}
+#if 1
+			//fprintf(fp, "sym=%d, key=%d, u=%d, mod=0x%0X\n",
+			//	(int)sdl_keysyms[k].key, key, event.key.keysym.unicode, (int)fl);
+			/* Try the Unicode if available? (bad for sticky and KBD_* keys) */
+			if (((key >= 'a') && (key <= 'z')) || ((key >= 'A') && (key <= 'Z')) || (key == ' '))
+			{
+			  //if (!(fl & KMOD_CTRL) && (event.key.keysym.unicode == 0)) // Dead key
+			  if (event.key.keysym.unicode == 0) // Dead key
+			  {
+			    switch (key) {
+			    case 'A':
+			    case 'G':
+			    case 'D':
+			    case 'F':
+			    case 'T':
+			    case 'C':
+			      dead_key = key;
+			    default:
+			      break;
+			    case 'V':
+			      dead_key = 'C'; // (doppleganger for c)
+			      break;
+			    }
+			    //if (dead_key) fprintf(fp, "  dead=%c\n", dead_key);
+			    //else fprintf(fp, "  undead=0\n");
+			    break;	/* skip COMPOSE (dead) keys */
+			  }
+			  else if (dead_key)
+			  {
+			    if((key == 'V') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			    {
+			      //fprintf(fp, "  decomposing %c+<%c>", dead_key, key);
+			      break; // (doppleganger for c)
+			    }
+			    //fprintf(fp, "  composing %c+<%c>", dead_key, key);
+			    if (key == ' ')
+			      key = 'Z'+1;
+			    if (dead_key == 'G') // (event.key.keysym.unicode == 0x300) // grave 
+			      key = grave_map[key - 'A'];
+			    else if (dead_key == 'A') // (event.key.keysym.unicode == 0x301) // acute 
+			      key = acute_map[key - 'A'];
+			    else if (dead_key == 'C') // (event.key.keysym.unicode == 0x302) // circum 
+			      key = circumflex_map[key - 'A'];
+			    else if (dead_key == 'T') // (event.key.keysym.unicode == 0x303) // tilde 
+			      key = tilde_map[key - 'A'];
+			    else if (dead_key == 'D') // (event.key.keysym.unicode == 0x308) // dia 
+			      key = diaeresis_map[key - 'A'];
+			    else if (dead_key == 'F') // (event.key.keysym.unicode == 0x327) // cedilla 
+			      key = cedilla_map[key - 'A'];
+			    dead_key = 0;
+			    //fprintf(fp, " = +<%c>\n", key);
+			  }
+#if 0
+			  else if((key == 'O') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for p)
+			  else if((key == 'M') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xBF; // Upside down question (instead of percent)
+			  else if((key == 'R') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xB0; // Happier place for degree
+#else
+			  else if((key == 'P') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for o)
+			  else if((key == 'Q') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    key = 0xBF; // Happier place for upside down question
+#endif
+			  else if((key == 'W') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+    			    break; // (doppleganger for e)
+#if 0
+			  else if((key == 'N') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			  {
+			    dead_key = 'C';  // Happier place for circumflex
+			    //fprintf(fp, "  fakedead=%c\n", dead_key);
+			    break;
+			  }
+#endif
+			  else if((key == 'V') && ((fl & KMOD_ALT) && (fl & KMOD_SHIFT)))
+			  {
+			    dead_key = 'C';  // Happier place for circumflex
+			    //fprintf(fp, "  fakeDEAD=%c\n", dead_key);
+			    break;
+			  }
+			  else
+			  {
+			  dead_key = 0;
+			  if (fl & KMOD_CTRL)
+			  {
+			    /* Skip unicode translation for ctrl keys. */
+			  } 
+			  else
+			  if (((event.key.keysym.unicode & 0xff80) == 0)) // ASCII
+			    key = event.key.keysym.unicode;
+			  else if ((event.key.keysym.unicode != 0) &&
+				   ((event.key.keysym.unicode & 0xff00) == 0)) // Latin 1 (8bit)
+			    key = event.key.keysym.unicode;
+			  else if (event.key.keysym.unicode == 0x20AC) // euro
+			    key = 0xA4; // Latin15
+			  //fprintf(fp, "  unicoding to <%c>\n", key);
+
+			  }
+			}
+			else
+			  dead_key = 0;
+#endif
+			//printf(fp, "  sym=%d, key=%d, u=%d, mod=0x%0X\n", (int)sdl_keysyms[k].key, key, event.key.keysym.unicode, (int)fl);
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+			/* If ALT changes the key on the Zipit then hide the SHIFT and ALT modifiers. */
+			if((event.key.keysym.mod & KMOD_ALT) && (key != sdl_keysyms[k].key))
+			  fl	&=	~(KBD_ALT|KBD_SHIFT);
+#else  /* not ZIPIT_Z2 */
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+			/* key re-map */
+			key	= sdl_keysyms[k].key;
+			/* upper letters fix (not handled directly by SDL) */
+			if(key >= 97 && key <= 122 && fl & KBD_SHIFT)
+			{	key	-= 32;
+				fl	&= ~KBD_SHIFT;	}
+			/* find modifiers */
+			fl	= 0;
+			if(event.key.keysym.mod & KMOD_SHIFT)
+				fl	|=	KBD_SHIFT;
+			if(event.key.keysym.mod & KMOD_ALT)
+				fl	|=	KBD_ALT;
+			if(event.key.keysym.mod & KMOD_CTRL)
+				fl	|=	KBD_CTRL;
+#endif
+			/* send keyb */
+			S_ON_DEBUG(fprintf(stderr, "KEY(%d) = %c&%d\n", k, key, fl););
+			if(fl & KBD_CTRL && sdl_keysyms[k].sym == SDLK_c)
+				sdl_GD(dev)->keyboard_handler(sdl_GD(dev), KBD_CTRL_C, 0);
+			else
+				sdl_GD(dev)->keyboard_handler(sdl_GD(dev), key, fl);
+                }break;
+	    case SDL_VIDEORESIZE:
+		/* new dims */
+		sdl_GD(dev)->size.x2	= event.resize.w;
+		sdl_GD(dev)->size.y2	= event.resize.h;
+		sdl_driver.x		= event.resize.w;
+		sdl_driver.y		= event.resize.h;
+		/* resize */
+		/* 
+		S_ON_DEBUG(fprintf(stderr, "RESIZE(%dx%d)\n", event.resize.w, event.resize.h));
+		*/
+		/* info resize */
+		sdl_GD(dev)->resize_handler(sdl_GD(dev));
+		break;
+/*
+	    case SDL_VIDEOEXPOSE:
+*/
+            case SDL_QUIT:
+                sdl_GD(dev)->keyboard_handler(sdl_GD(dev), KBD_CLOSE, 0);
+                break;
+	    default:
+		/* printf("Unhandled event: %d !\n", event.type); */
+		break;
+	}
+   }
+#undef event
+   sdl_SETUP_TIMER((void *)dev);
+   return;
+}
+
+static inline void sdl_update_sc(void *data)
+{
+	struct t_sdl_device_data	*dev	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	/* assing struct */
+	if(data == NULL)
+		return;
+	dev	= (struct t_sdl_device_data *)data;
+
+	/* check if update neccesary */
+	if(dev == NULL || sdl_SURFACE(dev) == NULL)
+		return;
+	if(!sdl_UPENDING(dev))
+		return;
+
+	/* do update screen */
+/*	SDL_UpdateRect(sdl_SURFACE(dev), sdl_URECT(dev).x, sdl_URECT(dev).y, sdl_URECT(dev).w, sdl_URECT(dev).h);
+*/
+	SDL_UpdateRect(sdl_SURFACE(dev), 0, 0, 0, 0);
+	/* remove pending flag */
+	sdl_UPENDING(dev)	= 0;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* quite stuppit function */
+#define sdl_NORM_UPDATE	0
+#define sdl_FULL_UPDATE 1
+static inline void sdl_register_update(struct t_sdl_device_data *dev, int x, int y, int w, int h, int opt)
+{
+	S_ON_DEBUG_TRACE("in");
+	sdl_UPENDING(dev)	= 1;
+	register_bottom_half(sdl_update_sc, dev);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* partialy stolen from documentation :)
+   XXX: we can quite easily add here alpha blending :))) */
+static inline void sdl_putpixel(SDL_Surface *s, int x, int y, unsigned long pixel)
+{
+     Uint8 *p;
+
+     /* check our clip rect */
+     if(!((s->clip_rect.x < x && (s->clip_rect.x + s->clip_rect.w) > x) 
+			&& (s->clip_rect.y < y && (s->clip_rect.y + s->clip_rect.h) > y)))
+	return;
+     /* our sanity (fight int overflow :) */
+     pixel &= (1<<(s->format->BytesPerPixel)) - 1; 
+     /* our point */
+     p = (Uint8 *)s->pixels + y * s->pitch + x * s->format->BytesPerPixel;
+     switch(s->format->BytesPerPixel) {
+     case 1:
+         *p = pixel;
+         break;
+     case 2:
+         *(Uint16 *)p = pixel;
+         break;
+
+     case 3:
+         if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
+             p[0] = (pixel >> 16) & 0xff;
+             p[1] = (pixel >> 8) & 0xff;
+             p[2] = pixel & 0xff;
+         } else {
+             p[0] = pixel & 0xff;
+             p[1] = (pixel >> 8) & 0xff;
+             p[2] = (pixel >> 16) & 0xff;
+         }
+         break;
+     case 4:
+         *(Uint32 *)p = pixel;
+         break;
+     }
+     return;
+}
+
+
+/* DRIVER FUNCTIONS */
+
+/* init driver */
+u_char_t *sdl_init_driver(u_char_t *param, u_char_t *display)
+{
+	S_ON_DEBUG_TRACE("in");
+	/* init sdl video */
+	if(SDL_Init(SDL_INIT_VIDEO) != 0)
+		return (u_char_t *)stracpy((u_char_t *)SDL_GetError());
+	
+	/* fetch current video hw informations */
+	sdl_DATA.video_info		= (SDL_VideoInfo *) mem_alloc(sizeof(SDL_VideoInfo));
+	S_ASSERT(sdl_DATA.video_info != NULL);
+	memcpy(sdl_DATA.video_info, SDL_GetVideoInfo(), (sizeof(SDL_VideoInfo)));
+	/* fetch driver name */
+	sdl_DATA.video_drv		= (u_char_t *)mem_alloc(sizeof(u_char_t) * 11);
+	S_ASSERT(sdl_DATA.video_drv != NULL);
+	SDL_VideoDriverName((char *)sdl_DATA.video_drv, 11);
+
+	/*TODO: SDL_VideoModeOk() */
+
+	/* setup mode */
+	sdl_VIDEO_FLAGS		|= SDL_HWSURFACE | SDL_HWPALETTE | SDL_RLEACCEL | SDL_RESIZABLE;
+	sdl_VIDEO_WIDTH		= 320; /* ZIPIT_Z2 */
+	sdl_VIDEO_HEIGHT	= 240; /* ZIPIT_Z2 */
+	sdl_VIDEO_DEPTH		= sdl_DATA.video_info->vfmt->BitsPerPixel;
+
+	/* set driv config */
+	sdl_driver.x		= sdl_VIDEO_WIDTH;
+	sdl_driver.y		= sdl_VIDEO_HEIGHT;
+	sdl_driver.depth	= ((sdl_DATA.video_info->vfmt->BytesPerPixel & 0x7) |
+                           ((sdl_DATA.video_info->vfmt->BitsPerPixel & 0x1F) << 3));
+
+	/* create cursor :) (need nice one) */
+#ifdef sdl_HAVE_CURSOR
+	if(sdl_DATA.cursor == NULL)
+	{
+		/* sdl_DATA.cursor	= SDL_CreateCursor((void *)arrow, (void *)arrow, 32, 32, 0, 0);
+		*/
+		S_ASSERT(sdl_DATA.cursor != NULL);
+	}
+#endif
+	/* key repeat */
+#ifdef ZIPIT_Z2
+	/* On the zipit EnableUNICODE will pass the red keys in the .unicode field */
+	/* Then I can read the .unicode field instead of the raw .key and .mod. */
+	/* But that runs into trouble with the sticky keymap. */
+#endif
+	SDL_EnableUNICODE(1);
+	SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
+
+	S_ON_DEBUG(fprintf(stderr, "VIDEO(%s): %dx%dx%d [%d]\n", sdl_DATA.video_drv,
+						sdl_VIDEO_WIDTH, sdl_VIDEO_HEIGHT, sdl_VIDEO_DEPTH, sdl_driver.depth));
+	return NULL;
+}
+
+/* shutdown driver */
+void sdl_shutdown_driver()
+{
+	S_ON_DEBUG_TRACE("in");
+	sdl_KILL_TIMER();
+	sdl_DATA_FREE();
+	SDL_Quit();
+	return;
+}
+
+/* create new graph device */
+struct graphics_device *sdl_init_device()
+{
+	struct graphics_device *dev	= NULL;
+	struct t_sdl_device_data *data	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* device data */
+	data			= (struct t_sdl_device_data *) mem_alloc(sizeof(struct t_sdl_device_data));
+	S_ASSERT(data != NULL);
+	memset(data, 0, sizeof(struct t_sdl_device_data));
+
+	/* init video mode */
+	sdl_SURFACE(data)	= SDL_SetVideoMode(sdl_VIDEO_WIDTH, sdl_VIDEO_HEIGHT, sdl_VIDEO_DEPTH, 
+							sdl_VIDEO_FLAGS);
+	if(sdl_SURFACE(data) == NULL)
+		return NULL;
+	SDL_SetAlpha(sdl_SURFACE(data), SDL_SRCALPHA, 0xff);
+
+	/* FIXME: here we shoulde re-update video info by calling SDL_VideoInfo() again */
+
+	/* alloc gd */
+	dev	= (struct graphics_device *) mem_alloc(sizeof(struct graphics_device));
+	S_ASSERT(dev != NULL);
+
+	/* setup gdS */
+	dev->size.x1		= 0;
+	dev->size.y1		= 0;
+	dev->size.x2		= sdl_VIDEO_WIDTH;
+	dev->size.y2		= sdl_VIDEO_HEIGHT;
+	dev->clip		= dev->size;
+
+	/*driver */
+	sdl_driver.flags	|= GD_NEED_CODEPAGE;
+	sdl_GD(data)		= dev;
+
+	/*driver */
+	dev->drv		= &sdl_driver;
+	dev->driver_data	= (void *) data;
+	dev->user_data		= NULL;
+
+	/*set my cursor */
+	if(sdl_DATA.cursor != NULL)
+		SDL_SetCursor(sdl_DATA.cursor);
+
+	/*init timer */
+	if(sdl_DATA.event_timer == 0)
+		sdl_SETUP_TIMER((void *)data);
+	S_ON_DEBUG_TRACE("out");
+	return dev;
+}
+
+/* destroy device */
+void sdl_shutdown_device(struct graphics_device *drv)
+{
+	struct t_sdl_device_data *dev	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	dev			= (struct t_sdl_device_data *) drv->driver_data;
+	S_ASSERT(dev != NULL);
+	
+	/* unregister bh */
+	unregister_bottom_half(sdl_update_sc, dev);
+
+	/* deinit video */
+	SDL_FreeSurface(sdl_SURFACE(dev));
+	sdl_SURFACE(dev)	= NULL;
+	mem_free(dev);
+	drv->driver_data	= NULL;
+	mem_free(drv);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* get driver parameters 
+   XXX: what is this fx() for ??? */
+u_char_t *sdl_get_driver_param()
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return NULL;
+}
+
+/* GRAPHICS */
+
+/* create empty bitmap */
+int sdl_get_empty_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* null */
+	bmp->data	= bmp->flags	= bmp->user	= NULL;
+	bmp->skip	= 0;
+
+	/* alloc surface */
+	/* FIXED: ignoring byteorder here (taking from video info) */
+	s		= (SDL_Surface *)SDL_CreateRGBSurface(sdl_VIDEO_FLAGS, bmp->x, bmp->y, sdl_VIDEO_DEPTH,
+					sdl_DATA.video_info->vfmt->Rmask, sdl_DATA.video_info->vfmt->Gmask, 
+					sdl_DATA.video_info->vfmt->Bmask, sdl_DATA.video_info->vfmt->Amask);
+	S_ASSERT(s != NULL);
+
+	/* copy data */
+	bmp->data	= (void *)s->pixels;
+	bmp->skip	= s->pitch;
+	bmp->flags	= (void *)s;
+
+	/* lock if required */
+	if(SDL_MUSTLOCK(s))
+		SDL_LockSurface(s);
+	S_ON_DEBUG_TRACE("out");
+	return 0;
+}
+
+/* create filled bitmap */
+int sdl_get_filled_bitmap(struct bitmap *bmp, long color)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return 0;
+}
+
+/* register bitmap */
+void sdl_register_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_UnlockSurface(s);
+	/* hide pixel mem */
+	bmp->data	= NULL;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* prepare strip */
+void *sdl_prepare_strip(struct bitmap *bmp, int top, int lines)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_LockSurface(s);
+	S_ON_DEBUG_TRACE("out");
+	return (void *)(s->pixels + (top * s->pitch));
+}
+
+/* commit strip */
+void sdl_commit_strip(struct bitmap *bmp, int top, int lines)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	/* unlock surface */
+	s	= (SDL_Surface *)bmp->flags;
+	if(SDL_MUSTLOCK(s))
+		SDL_UnlockSurface(s);
+	return;
+}
+
+/* unregister bitmap */
+void sdl_unregister_bitmap(struct bitmap *bmp)
+{
+	SDL_Surface	*s	= NULL;
+
+	S_ON_DEBUG_TRACE("in");
+
+	s		= (SDL_Surface *)bmp->flags;
+	S_ASSERT(s != 0);
+	/* delete data */
+	SDL_FreeSurface(s);
+	/* null data */
+	bmp->data	= NULL;
+	bmp->flags	= NULL;
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw bmp */
+void sdl_draw_bitmap(struct graphics_device *drv, struct bitmap *bmp, int x, int y)
+{
+	SDL_Surface		 *s	= NULL;
+	struct t_sdl_device_data *dev	= NULL;
+	SDL_Rect	rect;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	s	= (SDL_Surface *)bmp->flags;
+	memset(&rect, 0, sizeof(SDL_Rect));
+
+	/* blit :) */
+	rect.x	= x;
+	rect.y	= y;
+	SDL_BlitSurface(s, NULL, sdl_SURFACE(dev), &rect);
+	sdl_register_update(dev, rect.x, rect.y, rect.w, rect.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw more bmps */
+void sdl_draw_bitmaps(struct graphics_device *drv, struct bitmap **bmps, int n, int x, int y)
+{
+	int	i = 0;
+	struct t_sdl_device_data *dev	= NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	/* check */
+	if(n < 1)
+		return;
+
+	S_ON_DEBUG(fprintf(stderr, "draw_bitmaps(drv=%p, b=%p, n=%d,%d,%d)\n", drv, bmps, n,x,y));
+
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	S_ON_DEBUG_TRACE("1");
+	memset(&rect, 0, sizeof(SDL_Rect));
+
+	/* blit */
+	rect.x	= x;
+	rect.y	= y;
+	for(i = 0; i < n; i++)
+	{
+	  	S_ON_DEBUG_TRACE("2");
+		SDL_BlitSurface((SDL_Surface *)bmps[i]->flags, NULL, sdl_SURFACE(dev), &rect);
+		rect.x	+=	bmps[i]->x;	
+	}
+	/* FIXME: this should care about updating area, and possibly not update everythink */
+	S_ON_DEBUG_TRACE("3");
+	sdl_register_update(dev, 0, 0, 0, 0, sdl_FULL_UPDATE);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* get color */
+long sdl_get_color(int rgb)
+{
+	/*FIXME: not sure this is ok :) */
+	return SDL_MapRGB(sdl_DATA.video_info->vfmt, ((rgb >> 16) & 0xff), ((rgb >> 8) & 0xff), ((rgb) & 0xff));
+}
+
+/* fill some area */
+void sdl_fill_area(struct graphics_device *drv, int x1, int y1, int x2, int y2, long color)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+
+	rect.x	= x1;
+	rect.y	= y1;
+	rect.w	= x2 - x1;
+	rect.h	= y2 - y1;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	SDL_FillRect(sdl_SURFACE(dev), &rect, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev, rect.x, rect.y, rect.w, rect.h, 0);
+/*	sdl_register_update(dev, x1, y1, x2, y2, 0);
+*/
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw horizontal line */
+void sdl_draw_hline(struct graphics_device *drv, int left, int y, int right, long color)
+{
+	register int	i	= 0;
+	struct t_sdl_device_data *dev = NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	for(i = left; i < right; i++)
+		sdl_putpixel(sdl_SURFACE(dev), i, y, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev,  left, y, 1, right - left, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* draw vertical line */
+void sdl_draw_vline(struct graphics_device *drv, int x, int top, int bottom, long color)
+{
+	register int i = 0;
+	struct t_sdl_device_data *dev = NULL;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_LockSurface(sdl_SURFACE(dev));
+	for(i = top; i < bottom; i++)
+		sdl_putpixel(sdl_SURFACE(dev), x, i, color);
+	if(SDL_MUSTLOCK(sdl_SURFACE(dev)))
+		SDL_UnlockSurface(sdl_SURFACE(dev));
+	sdl_register_update(dev, x, top, bottom - top, 1, 0);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+/* horizontal scroll */
+int sdl_hscroll(struct graphics_device *drv, struct rect_set **set, int sc)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect1, rect2;
+
+	S_ON_DEBUG_TRACE("in");
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+	/* rect1 */
+	rect1.x = drv->clip.x1;
+	rect1.y = drv->clip.y1;
+	rect1.w = drv->clip.x2 - rect1.x;
+	rect1.h = drv->clip.y2 - rect1.y;
+
+	/* rect2 */
+	rect2.x = drv->clip.x1 + sc;
+	rect2.y = drv->clip.y1;
+	rect2.w = drv->clip.x2 - rect1.x;
+	rect2.h = drv->clip.y2 - rect1.y;
+
+	SDL_BlitSurface(sdl_SURFACE(dev), &rect1, sdl_SURFACE(dev), &rect2);
+	sdl_register_update(dev, rect1.x, rect1.y, rect1.w, rect1.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return 1;
+}
+
+/* vertical scroll */
+int sdl_vscroll(struct graphics_device *drv, struct rect_set **set, int sc)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect1, rect2;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+
+	/* rect1 */
+	rect1.x = drv->clip.x1;
+	rect1.y = drv->clip.y1;
+	rect1.w = drv->clip.x2 - rect1.x;
+	rect1.h = drv->clip.y2 - rect1.y;
+
+	/* rect2 */
+	rect2.x = drv->clip.x1;
+	rect2.y = drv->clip.y1 + sc;
+	rect2.w = drv->clip.x2 - rect1.x;
+	rect2.h = drv->clip.y2 - rect1.y;
+
+	SDL_BlitSurface(sdl_SURFACE(dev), &rect1, sdl_SURFACE(dev), &rect2);
+	sdl_register_update(dev, rect1.x, rect1.y, rect1.w, rect1.h, 0);
+	S_ON_DEBUG_TRACE("out");
+	return 1;
+}
+
+/* set cliping area */
+void sdl_set_clip_area(struct graphics_device *drv, struct rect *r)
+{
+	struct t_sdl_device_data *dev = NULL;
+	SDL_Rect rect;
+
+	S_ON_DEBUG_TRACE("in");
+	/* get ptr */
+	dev	= (struct t_sdl_device_data *) drv->driver_data;
+	/* set rect */
+	rect.x	= r->x1;
+	rect.y	= r->y1;
+	rect.w	= r->x2 - r->x1;
+	rect.h	= r->y2 - r->y1;
+	/* dev clipp */
+	drv->clip	= *r;
+	/* clipp */
+	SDL_SetClipRect(sdl_SURFACE(dev), &rect);
+	S_ON_DEBUG_TRACE("out");
+	return;
+}
+
+
+/* block dev
+int sdl_block(struct graphics_device *drv)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return 0;
+}
+*/
+
+
+/* unblock dev
+void sdl_unblock(struct graphics_device *drv)
+{
+	S_ON_DEBUG_TRACE("in");
+	S_ASSERT(0);
+	return;
+}
+*/
+
+/* set window title (tittle utf-8 encoded !!!!) */
+void sdl_set_title(struct graphics_device *drv, u_char_t *title)
+{
+	S_ON_DEBUG_TRACE("in");
+	SDL_WM_SetCaption((const char *)title, NULL);
+	return;
+}
+
+
+
+/* driver definition data */
+struct graphics_driver sdl_driver={
+	"sdl",
+	sdl_init_driver,
+	sdl_init_device,
+	sdl_shutdown_device,
+	sdl_shutdown_driver,
+	sdl_get_driver_param,
+	sdl_get_empty_bitmap,
+	/*sdl_get_filled_bitmap,*/
+	sdl_register_bitmap,
+	sdl_prepare_strip,
+	sdl_commit_strip,
+	sdl_unregister_bitmap,
+	sdl_draw_bitmap,
+	sdl_draw_bitmaps,
+	sdl_get_color,	/* sdl_get_color */
+	sdl_fill_area,
+	sdl_draw_hline,
+	sdl_draw_vline,
+	sdl_hscroll,
+	sdl_vscroll,
+	sdl_set_clip_area,
+	dummy_block,
+	dummy_unblock,
+	NULL, /* sdl_set_title,*/	/* set_title */
+	NULL, /* exec */
+	0,				/* depth (filled in sdl_init_driver function) */
+	0, 0,				/* size (in X is empty) */
+	0,				/* flags */
+	0,				/* codepage */
+	NULL				/* shell */
+};
+
+
+
+#endif /* GRDRV_SDL */
+
diff -rupN links-2.3pre1.orig/sdl_data.inc links-2.3pre1/sdl_data.inc
--- links-2.3pre1.orig/sdl_data.inc	1969-12-31 19:00:00.000000000 -0500
+++ links-2.3pre1/sdl_data.inc	2012-06-22 09:42:27.000000000 -0400
@@ -0,0 +1,400 @@
+/**
+  sdl key syms
+
+  XXX: i'know this is stupit but i'm preparing for some good solution :)
+
+*/
+
+
+#ifndef _SDL_KEYS_INC
+#define _SDL_KEYS_INC
+
+#define ZIPIT_Z2 1
+
+struct t_sdl_keysym
+{
+	unsigned short	sym;
+	int		key;
+#ifdef ZIPIT_Z2
+        int		skey; 
+        int		akey; 
+        int		sakey;
+#endif
+};
+
+#ifdef ZIPIT_Z2
+/* dead key accent mappings for latin15 */
+int acute_map[] = {
+0xC1,'B','C','D',0xC9,'F','G','H',0xCD,'J','K','L','M','N',0xD3,'P','Q','R','S','T',0xDA,'V','W','X',0xDD,'Z',
+'\'',0,0,0,0,0,
+0xE1,'b','c','d',0xE9,'f','g','h',0xED,'j','k','l','m','n',0xF3,'p','q','r','s','t',0xFA,'v','w','x',0xFD,'z'};
+int grave_map[] = {
+0xC0,'B','C','D',0xC8,'F','G','H',0xCC,'J','K','L','M','N',0xD2,'P','Q','R','S','T',0xD9,'V','W','X','Y','Z',
+'`',0,0,0,0,0,
+0xE0,'b','c','d',0xE8,'f','g','h',0xEC,'j','k','l','m','n',0xF2,'p','q','r','s','t',0xF9,'v','w','x','y','z'};
+int circumflex_map[] = {
+0xC2,'B','C','D',0xCA,'F','G','H',0xCE,'J','K','L','M','N',0xD4,'P','Q','R','S','T',0xDB,'V','W','X','Y','Z',
+'^',0,0,0,0,0,
+0xE2,'b','c','d',0xEA,'f','g','h',0xEE,'j','k','l','m','n',0xF4,'p','q','r','s','t',0xFB,'v','w','x','y','z'};
+int diaeresis_map[] = {
+0xC4,'B','C','D',0xCB,'F','G','H',0xCF,'J','K','L','M','N',0xD6,'P','Q','R','S','T',0xDC,'V','W','X','Y','Z',
+'\"',0,0,0,0,0,
+0xE4,'b','c','d',0xEB,'f','g','h',0xEF,'j','k','l','m','n',0xF6,'p','q','r','s','t',0xFC,'v','w','x',0xFF,'z'};
+int cedilla_map[] = {
+'A','B',0xC7,'D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
+',',0,0,0,0,0,
+'a','b',0xE7,'d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
+int tilde_map[] = {
+0xC3,'B','C','D','E','F','G','H','I','J','K','L','M',0xD1,0xD5,'P','Q','R','S','T','U','V','W','X','Y','Z',
+'~',0,0,0,0,0,
+0xE3,'b','c','d','e','f','g','h','i','j','k','l','m',0xF1,0xF5,'p','q','r','s','t','u','v','w','x','y','z'};
+#endif
+
+/* big mapping SDL->LINKS */
+static struct t_sdl_keysym sdl_keysyms[] =
+{
+#ifdef ZIPIT_Z2
+	{ SDLK_UNKNOWN		,0 ,0, 0, 0},
+	{ SDLK_FIRST		,0 ,0, 0, 0},
+	{ SDLK_ESCAPE,KBD_ESC,KBD_ESC,'|',KBD_ESC},
+	{ SDLK_0,'0',')','0',')'},
+	{ SDLK_1,'1','!','1','!'},
+	{ SDLK_2,'2','@','2','@'},
+	{ SDLK_3,'3','#','3','#'},
+	{ SDLK_4,'4','$','4','$'},
+	{ SDLK_5,'5','%','5','%'},
+	{ SDLK_6,'6','^','6','^'},
+	{ SDLK_7,'7','&','7','&'},
+	{ SDLK_8,'8','*','8','*'},
+	{ SDLK_9,'9','(','9','('},
+	{ SDLK_a,'a','A','$','A'},
+	{ SDLK_b,'b','B','=','B'},
+	{ SDLK_c,'c','C','+','C'},
+	{ SDLK_d,'d','D','&','D'},
+	{ SDLK_e,'e','E','3','E'},
+	{ SDLK_f,'f','F','@','F'},
+	{ SDLK_g,'g','G','"','G'},
+	{ SDLK_h,'h','H','\'','`'},
+	{ SDLK_i,'i','I','8','I'},
+	{ SDLK_j,'j','J','[','J'},
+	{ SDLK_k,'k','K',']','`'},
+	{ SDLK_l,'l','L','-','|'},
+	{ SDLK_m,'m','M','?','%'},
+	{ SDLK_n,'n','N','_','N'},
+	{ SDLK_o,'o','O','9','O'},
+	{ SDLK_p,'p','P','0','P'},
+	{ SDLK_q,'q','Q','1','Q'},
+	{ SDLK_r,'r','R','4','R'},
+	{ SDLK_s,'s','S','#','S'},
+	{ SDLK_t,'t','T','5','T'},
+	{ SDLK_u,'u','U','7','U'},
+	{ SDLK_v,'v','V','*','V'},
+	{ SDLK_w,'w','W','2','W'},
+	{ SDLK_x,'x','X','/','\\'},
+	{ SDLK_y,'y','Y','6','Y'},
+	{ SDLK_z,'z','Z','!','C'},
+	{ SDLK_MINUS,'-','_','-','_'},
+	{ SDLK_EQUALS,'=','+','=','+'},
+	{ SDLK_LEFTBRACKET,'[','{','[','{'},
+	{ SDLK_RIGHTBRACKET,']','}',']','}'},
+	{ SDLK_SEMICOLON,';','~',':','^'},
+	{ SDLK_QUOTE,'\'','"','\'','"'},
+	{ SDLK_BACKSLASH,'\\','|','\\','|'},
+	{ SDLK_SLASH,'/','?','/','?'},
+	{ SDLK_PERIOD,'.',')','>','}'},
+	{ SDLK_COMMA,',','(','<','{'},
+	{ SDLK_BACKQUOTE,'`','~','`','~'},
+	{ SDLK_BACKSPACE,KBD_BS,KBD_BS,KBD_BS,KBD_BS},
+	{ SDLK_TAB,KBD_TAB,KBD_TAB,'~',KBD_TAB},
+	{ SDLK_DELETE,127,127,127,127},
+	{ SDLK_RETURN,KBD_ENTER,KBD_ENTER,KBD_ENTER,KBD_ENTER},
+	{ SDLK_F1,KBD_F1,KBD_F1,KBD_F1,KBD_F1},
+	{ SDLK_F2,KBD_F2,KBD_F2,KBD_F2,KBD_F2},
+	{ SDLK_F3,KBD_F3,KBD_F3,KBD_F3,KBD_F3},
+	{ SDLK_F4,KBD_F4,KBD_F4,KBD_F4,KBD_F4},
+	{ SDLK_F5,KBD_F5,KBD_F5,KBD_F5,KBD_F5},
+	{ SDLK_F6,KBD_F6,KBD_F6,KBD_F6,KBD_F6},
+	{ SDLK_F7,KBD_F7,KBD_F7,KBD_F7,KBD_F7},
+	{ SDLK_F8,KBD_F8,KBD_F8,KBD_F8,KBD_F8},
+	{ SDLK_F9,KBD_F9,KBD_F9,KBD_F9,KBD_F9},
+	{ SDLK_F10,KBD_F10,KBD_F10,KBD_F10,KBD_F10},
+	{ SDLK_ESCAPE,0x1b,0x1b,'|',0x1b},
+
+	{ SDLK_LEFT,KBD_LEFT,KBD_LEFT,KBD_LEFT,KBD_LEFT},
+	{ SDLK_RIGHT,KBD_RIGHT,KBD_RIGHT,KBD_RIGHT,KBD_RIGHT},
+	{ SDLK_UP,KBD_UP,KBD_UP,KBD_UP,KBD_UP},
+	{ SDLK_DOWN,KBD_DOWN,KBD_DOWN,KBD_DOWN,KBD_DOWN},
+//	{ SDLK_PAGEUP,KBD_PAGE_UP,KBD_PAGE_UP,']', KBD_PAGE_UP},
+//	{ SDLK_PAGEDOWN,KBD_PAGE_DOWN,KBD_PAGE_DOWN, '[', KBD_PAGE_DOWN},
+//      The [] was a hack for left/rt, but INS/DEL for scroll is a better fit.
+	{ SDLK_PAGEUP,KBD_PAGE_UP,KBD_PAGE_UP,KBD_INS, KBD_INS},
+	{ SDLK_PAGEDOWN,KBD_PAGE_DOWN,KBD_PAGE_DOWN, KBD_DEL, KBD_DEL},
+	{ SDLK_SPACE,' ',' ',' ',' '},
+	{ SDLK_HOME,KBD_HOME,KBD_HOME,KBD_PAGE_UP,KBD_PAGE_UP},
+	{ SDLK_END,KBD_END,KBD_END,KBD_PAGE_DOWN,KBD_PAGE_DOWN},
+
+	{ SDLK_LALT,308,308,308,308},
+	{ SDLK_RALT,307,307,307,307},
+	{ SDLK_LCTRL,306,306,306,306},
+	{ SDLK_RCTRL,305,305,305,305},
+	{ SDLK_LSHIFT,304,304,304,304},
+	{ SDLK_RSHIFT,303,303,303,303},
+  { SDLK_LAST		,0 ,0, 0, 0},
+#else
+	{ SDLK_UNKNOWN		,0 },
+	{ SDLK_FIRST		,0 },
+	{ SDLK_BACKSPACE	,KBD_BS },
+	{ SDLK_TAB		,KBD_TAB },
+	{ SDLK_CLEAR		,12 },
+	{ SDLK_RETURN		,KBD_ENTER },
+	{ SDLK_PAUSE		,19 },
+	{ SDLK_ESCAPE		,KBD_ESC },
+	{ SDLK_SPACE		,32 },
+	{ SDLK_EXCLAIM		,33 },
+	{ SDLK_QUOTEDBL		,34 },
+	{ SDLK_HASH		,35 },
+	{ SDLK_DOLLAR		,36 },
+	{ SDLK_AMPERSAND		,38 },
+	{ SDLK_QUOTE		,39 },
+	{ SDLK_LEFTPAREN		,40 },
+	{ SDLK_RIGHTPAREN		,41 },
+	{ SDLK_ASTERISK		,42 },
+	{ SDLK_PLUS		,43 },
+	{ SDLK_COMMA		,44 },
+	{ SDLK_MINUS		,45 },
+	{ SDLK_PERIOD		,46 },
+	{ SDLK_SLASH		,47 },
+	{ SDLK_0			,48 },
+	{ SDLK_1			,49 },
+	{ SDLK_2			,50 },
+	{ SDLK_3			,51 },
+	{ SDLK_4			,52 },
+	{ SDLK_5			,53 },
+	{ SDLK_6			,54 },
+	{ SDLK_7			,55 },
+	{ SDLK_8			,56 },
+	{ SDLK_9			,57 },
+	{ SDLK_COLON		,58 },
+	{ SDLK_SEMICOLON		,59 },
+	{ SDLK_LESS		,60 },
+	{ SDLK_EQUALS		,61 },
+	{ SDLK_GREATER		,62 },
+	{ SDLK_QUESTION		,63 },
+	{ SDLK_AT			,64 },
+	/* 
+	   Skip uppercase letters
+	 */
+	{ SDLK_LEFTBRACKET	,91 },
+	{ SDLK_BACKSLASH		,92 },
+	{ SDLK_RIGHTBRACKET	,93 },
+	{ SDLK_CARET		,94 },
+	{ SDLK_UNDERSCORE		,95 },
+	{ SDLK_BACKQUOTE		,96 },
+	{ SDLK_a			,97 },
+	{ SDLK_b			,98 },
+	{ SDLK_c			,99 },
+	{ SDLK_d			,100 },
+	{ SDLK_e			,101 },
+	{ SDLK_f			,102 },
+	{ SDLK_g			,103 },
+	{ SDLK_h			,104 },
+	{ SDLK_i			,105 },
+	{ SDLK_j			,106 },
+	{ SDLK_k			,107 },
+	{ SDLK_l			,108 },
+	{ SDLK_m			,109 },
+	{ SDLK_n			,110 },
+	{ SDLK_o			,111 },
+	{ SDLK_p			,112 },
+	{ SDLK_q			,113 },
+	{ SDLK_r			,114 },
+	{ SDLK_s			,115 },
+	{ SDLK_t			,116 },
+	{ SDLK_u			,117 },
+	{ SDLK_v			,118 },
+	{ SDLK_w			,119 },
+	{ SDLK_x			,120 },
+	{ SDLK_y			,121 },
+	{ SDLK_z			,122 },
+	{ SDLK_DELETE		,127 },
+	/* End of ASCII mapped keysyms */
+
+	/* International keyboard syms */
+	{ SDLK_WORLD_0		,160 },		/* 0xA0 */
+	{ SDLK_WORLD_1		,161 },
+	{ SDLK_WORLD_2		,162 },
+	{ SDLK_WORLD_3		,163 },
+	{ SDLK_WORLD_4		,164 },
+	{ SDLK_WORLD_5		,165 },
+	{ SDLK_WORLD_6		,166 },
+	{ SDLK_WORLD_7		,167 },
+	{ SDLK_WORLD_8		,168 },
+	{ SDLK_WORLD_9		,169 },
+	{ SDLK_WORLD_10		,170 },
+	{ SDLK_WORLD_11		,171 },
+	{ SDLK_WORLD_12		,172 },
+	{ SDLK_WORLD_13		,173 },
+	{ SDLK_WORLD_14		,174 },
+	{ SDLK_WORLD_15		,175 },
+	{ SDLK_WORLD_16		,176 },
+	{ SDLK_WORLD_17		,177 },
+	{ SDLK_WORLD_18		,178 },
+	{ SDLK_WORLD_19		,179 },
+	{ SDLK_WORLD_20		,180 },
+	{ SDLK_WORLD_21		,181 },
+	{ SDLK_WORLD_22		,182 },
+	{ SDLK_WORLD_23		,183 },
+	{ SDLK_WORLD_24		,184 },
+	{ SDLK_WORLD_25		,185 },
+	{ SDLK_WORLD_26		,186 },
+	{ SDLK_WORLD_27		,187 },
+	{ SDLK_WORLD_28		,188 },
+	{ SDLK_WORLD_29		,189 },
+	{ SDLK_WORLD_30		,190 },
+	{ SDLK_WORLD_31		,191 },
+	{ SDLK_WORLD_32		,192 },
+	{ SDLK_WORLD_33		,193 },
+	{ SDLK_WORLD_34		,194 },
+	{ SDLK_WORLD_35		,195 },
+	{ SDLK_WORLD_36		,196 },
+	{ SDLK_WORLD_37		,197 },
+	{ SDLK_WORLD_38		,198 },
+	{ SDLK_WORLD_39		,199 },
+	{ SDLK_WORLD_40		,200 },
+	{ SDLK_WORLD_41		,201 },
+	{ SDLK_WORLD_42		,202 },
+	{ SDLK_WORLD_43		,203 },
+	{ SDLK_WORLD_44		,204 },
+	{ SDLK_WORLD_45		,205 },
+	{ SDLK_WORLD_46		,206 },
+	{ SDLK_WORLD_47		,207 },
+	{ SDLK_WORLD_48		,208 },
+	{ SDLK_WORLD_49		,209 },
+	{ SDLK_WORLD_50		,210 },
+	{ SDLK_WORLD_51		,211 },
+	{ SDLK_WORLD_52		,212 },
+	{ SDLK_WORLD_53		,213 },
+	{ SDLK_WORLD_54		,214 },
+	{ SDLK_WORLD_55		,215 },
+	{ SDLK_WORLD_56		,216 },
+	{ SDLK_WORLD_57		,217 },
+	{ SDLK_WORLD_58		,218 },
+	{ SDLK_WORLD_59		,219 },
+	{ SDLK_WORLD_60		,220 },
+	{ SDLK_WORLD_61		,221 },
+	{ SDLK_WORLD_62		,222 },
+	{ SDLK_WORLD_63		,223 },
+	{ SDLK_WORLD_64		,224 },
+	{ SDLK_WORLD_65		,225 },
+	{ SDLK_WORLD_66		,226 },
+	{ SDLK_WORLD_67		,227 },
+	{ SDLK_WORLD_68		,228 },
+	{ SDLK_WORLD_69		,229 },
+	{ SDLK_WORLD_70		,230 },
+	{ SDLK_WORLD_71		,231 },
+	{ SDLK_WORLD_72		,232 },
+	{ SDLK_WORLD_73		,233 },
+	{ SDLK_WORLD_74		,234 },
+	{ SDLK_WORLD_75		,235 },
+	{ SDLK_WORLD_76		,236 },
+	{ SDLK_WORLD_77		,237 },
+	{ SDLK_WORLD_78		,238 },
+	{ SDLK_WORLD_79		,239 },
+	{ SDLK_WORLD_80		,240 },
+	{ SDLK_WORLD_81		,241 },
+	{ SDLK_WORLD_82		,242 },
+	{ SDLK_WORLD_83		,243 },
+	{ SDLK_WORLD_84		,244 },
+	{ SDLK_WORLD_85		,245 },
+	{ SDLK_WORLD_86		,246 },
+	{ SDLK_WORLD_87		,247 },
+	{ SDLK_WORLD_88		,248 },
+	{ SDLK_WORLD_89		,249 },
+	{ SDLK_WORLD_90		,250 },
+	{ SDLK_WORLD_91		,251 },
+	{ SDLK_WORLD_92		,252 },
+	{ SDLK_WORLD_93		,253 },
+	{ SDLK_WORLD_94		,254 },
+	{ SDLK_WORLD_95		,255 },		/* 0xFF */
+
+	/* Numeric keypad */
+	{ SDLK_KP0		,256 },
+	{ SDLK_KP1		,257 },
+	{ SDLK_KP2		,258 },
+	{ SDLK_KP3		,259 },
+	{ SDLK_KP4		,260 },
+	{ SDLK_KP5		,261 },
+	{ SDLK_KP6		,262 },
+	{ SDLK_KP7		,263 },
+	{ SDLK_KP8		,264 },
+	{ SDLK_KP9		,265 },
+	{ SDLK_KP_PERIOD	,266 },
+	{ SDLK_KP_DIVIDE	,267 },
+	{ SDLK_KP_MULTIPLY	,268 },
+	{ SDLK_KP_MINUS		,269 },
+	{ SDLK_KP_PLUS		,270 },
+	{ SDLK_KP_ENTER		,KBD_ENTER },
+	{ SDLK_KP_EQUALS	,272 },
+
+	/* Arrows + Home/End pad */
+	{ SDLK_UP		,KBD_UP },
+	{ SDLK_DOWN		,KBD_DOWN },
+	{ SDLK_RIGHT		,KBD_RIGHT },
+	{ SDLK_LEFT		,KBD_LEFT },
+	{ SDLK_INSERT		,KBD_INS },
+	{ SDLK_HOME		,KBD_HOME },
+	{ SDLK_END		,KBD_END },
+	{ SDLK_PAGEUP		,KBD_PAGE_UP },
+	{ SDLK_PAGEDOWN		,KBD_PAGE_DOWN },
+
+	/* Function keys */
+	{ SDLK_F1		,KBD_F1 },
+	{ SDLK_F2		,KBD_F2 },
+	{ SDLK_F3		,KBD_F3 },
+	{ SDLK_F4		,KBD_F4 },
+	{ SDLK_F5		,KBD_F5 },
+	{ SDLK_F6		,KBD_F6 },
+	{ SDLK_F7		,KBD_F7 },
+	{ SDLK_F8		,KBD_F8 },
+	{ SDLK_F9		,KBD_F9 },
+	{ SDLK_F10		,KBD_F10 },
+	{ SDLK_F11		,KBD_F11 },
+	{ SDLK_F12		,KBD_F12 },
+	{ SDLK_F13		,294 },
+	{ SDLK_F14		,295 },
+	{ SDLK_F15		,296 },
+
+	/* Key state modifier keys */
+	{ SDLK_NUMLOCK		,300 },
+	{ SDLK_CAPSLOCK		,301 },
+	{ SDLK_SCROLLOCK		,302 },
+	{ SDLK_RSHIFT		,303 },
+	{ SDLK_LSHIFT		,304 },
+	{ SDLK_RCTRL		,305 },
+	{ SDLK_LCTRL		,306 },
+	{ SDLK_RALT		,307 },
+	{ SDLK_LALT		,308 },
+	{ SDLK_RMETA		,309 },
+	{ SDLK_LMETA		,310 },
+	{ SDLK_LSUPER		,311 },		/* Left "Windows" key */
+	{ SDLK_RSUPER		,312 },		/* Right "Windows" key */
+	{ SDLK_MODE		,313 },		/* "Alt Gr" key */
+	{ SDLK_COMPOSE		,314 },		/* Multi-key compose key */
+
+	/* Miscellaneous function keys */
+	{ SDLK_HELP		,315 },
+	{ SDLK_PRINT		,316 },
+	{ SDLK_SYSREQ		,317 },
+	{ SDLK_BREAK		,318 },
+	{ SDLK_MENU		,KBD_F9 },
+	{ SDLK_POWER		,320 },		/* Power Macintosh power key */
+	{ SDLK_EURO		,321 },		/* Some european keyboards */
+	{ SDLK_UNDO		,322 },		/* Atari keyboard has Undo */
+
+	/* Add any other keys here */
+
+	{ SDLK_LAST		,0  },
+#endif
+};
+
+#endif
diff -rupN links-2.3pre1.orig/setup.h links-2.3pre1/setup.h
--- links-2.3pre1.orig/setup.h	2009-09-08 00:11:03.000000000 -0400
+++ links-2.3pre1/setup.h	2012-06-22 09:36:06.000000000 -0400
@@ -138,7 +138,12 @@
 #define G_DIALOG_BUTTON_L		"[ "
 #define G_DIALOG_BUTTON_R		" ]"
 
+#if 1 /* ZIPIT_Z2 */
+/* Shave a few pixels off the big fat scroll bar. */
+#define G_SCROLL_BAR_WIDTH		8
+#else
 #define G_SCROLL_BAR_WIDTH		12
+#endif
 #define G_SCROLL_BAR_MIN_SIZE		20
 #define G_DEFAULT_SCROLL_BAR_FRAME_COLOR	0x000000
 #define G_DEFAULT_SCROLL_BAR_AREA_COLOR		0xc0c0c0
diff -rupN links-2.3pre1.orig/view.c links-2.3pre1/view.c
--- links-2.3pre1.orig/view.c	2011-08-14 13:43:04.000000000 -0400
+++ links-2.3pre1/view.c	2012-06-22 09:35:58.000000000 -0400
@@ -3016,7 +3016,12 @@ static int frame_ev(struct session *ses,
 		return 1;
 	}
 	if (ev->ev == EV_KBD) {
+#if 1 /* ZIPIT_Z2 */
+		/* Add more conveient scroll keys for ZIPIT_Z2 */
+		if (ev->x == KBD_PAGE_DOWN || (upcase(ev->x) == 'F' && ev->y & KBD_CTRL)) rep_ev(ses, fd, page_down, 0);
+#else
 		if (ev->x == KBD_PAGE_DOWN || (ev->x == ' ' && (!(ev->y & KBD_ALT))) || (upcase(ev->x) == 'F' && ev->y & KBD_CTRL)) rep_ev(ses, fd, page_down, 0);
+#endif
 		else if (ev->x == KBD_PAGE_UP || (upcase(ev->x) == 'B' && (!(ev->y & KBD_ALT)))) rep_ev(ses, fd, page_up, 0);
 		else if (ev->x == KBD_DOWN) rep_ev(ses, fd, down, 0);
 		else if (ev->x == KBD_UP) rep_ev(ses, fd, up, 0);
@@ -3038,9 +3043,22 @@ static int frame_ev(struct session *ses,
 			}
 		}
 		else if (ev->x == KBD_INS || (upcase(ev->x) == 'P' && ev->y & KBD_CTRL)) rep_ev(ses, fd, scroll, -1 - !ses->kbdprefix.rep);
+#if 1 /* ZIPIT_Z2 */
+		/* Add more conveient scroll keys for ZIPIT_Z2 */
+		else if (ev->x == KBD_DEL || (upcase(ev->x) == 'N' && ev->y & KBD_CTRL) 
+			 || (ev->x == ' ' && !(ev->y & KBD_ALT))) 
+		  rep_ev(ses, fd, scroll, 1 + !ses->kbdprefix.rep);
+		/* Allow TAB, BACKTAB to traverse links on ZIPIT_Z2 */
+		else if ((ev->x == KBD_TAB) && (ev->y & KBD_SHIFT)) rep_ev(ses, fd, up, 0);
+		else if (ev->x == KBD_TAB) rep_ev(ses, fd, down, 0);
+		/* Add more conveient sidescroll keys for ZIPIT_Z2 */
+		else if ((ev->x == '[') || (ev->x == ',') || (ev->x == '<')) rep_ev(ses, fd, hscroll, -1 - 7 * !ses->kbdprefix.rep);
+		else if ((ev->x == ']') || (ev->x == '.') || (ev->x == '>')) rep_ev(ses, fd, hscroll, 1 + 7 * !ses->kbdprefix.rep);
+#else
 		else if (ev->x == KBD_DEL || (upcase(ev->x) == 'N' && ev->y & KBD_CTRL)) rep_ev(ses, fd, scroll, 1 + !ses->kbdprefix.rep);
 		else if (ev->x == '[') rep_ev(ses, fd, hscroll, -1 - 7 * !ses->kbdprefix.rep);
 		else if (ev->x == ']') rep_ev(ses, fd, hscroll, 1 + 7 * !ses->kbdprefix.rep);
+#endif
 		/*else if (upcase(ev->x) == 'Y' && ev->y & KBD_CTRL) rep_ev(ses, fd, scroll, -1);
 		else if (upcase(ev->x) == 'E' && ev->y & KBD_CTRL) rep_ev(ses, fd, scroll, 1);*/
 		else if (ev->x == KBD_HOME || (upcase(ev->x) == 'A' && ev->y & KBD_CTRL)) rep_ev(ses, fd, home, 0);
diff -rupN links-2.3pre1.orig/view_gr.c links-2.3pre1/view_gr.c
--- links-2.3pre1.orig/view_gr.c	2011-04-19 10:17:50.000000000 -0400
+++ links-2.3pre1/view_gr.c	2012-06-22 09:35:58.000000000 -0400
@@ -989,6 +989,43 @@ static void unset_link(struct f_data_c *
 	}
 }
 
+#if 1 /* ZIPIT_Z2 */
+unsigned char scrollmark_file[MAX_STR_LEN]="";
+static int read_scrollmark(struct session *ses, struct f_data_c *fd, int a)
+{
+	unsigned int pos = 0;
+	unsigned char *buf;
+
+	if (!*scrollmark_file)
+		snprintf(scrollmark_file,MAX_STR_LEN,"%sscrollmark.cfg",links_home?links_home:(unsigned char*)"");
+
+	buf=read_config_file(scrollmark_file);
+	if (a && buf){
+		pos = atoi(buf);
+		unset_link(fd);
+		if (pos > fd->f_data->y - fd->yw + fd->f_data->hsb * G_SCROLL_BAR_WIDTH) {
+			return 0;
+		}
+		fd->vs->view_pos = pos;
+		fd->vs->orig_view_pos = fd->vs->view_pos;
+		return 3;
+	}
+	return 0;
+}
+
+static int write_scrollmark(struct session *ses, struct f_data_c *f)
+{
+	unsigned char buf[80];
+	unsigned int pos = 0;
+
+	if (!*scrollmark_file)
+	  read_scrollmark(ses, f, 0); /* 0 means just read, do not scroll*/
+
+	sprintf(buf, "%d\n", f->vs->view_pos);
+	write_to_config_file(scrollmark_file, buf);
+}
+#endif /* ZIPIT_Z2 */
+
 int g_frame_ev(struct session *ses, struct f_data_c *fd, struct event *ev)
 {
 	if (!fd->f_data) return 0;
@@ -1145,7 +1182,16 @@ int g_frame_ev(struct session *ses, stru
 				}
 				return enter(ses, fd, 0);
 			}
+#if 1 /* ZIPIT_Z2 */
+			/* Add scroll mark for ZIPIT_Z2 ereading. */
+			if (upcase(ev->x) == 'R' && !(ev->y & (KBD_CTRL | KBD_ALT))) return read_scrollmark(ses,fd, 1);
+			if (upcase(ev->x) == 'M' && !(ev->y & (KBD_CTRL | KBD_ALT))) return write_scrollmark(ses,fd); 
+
+			/* Add more conveient croll keys for ZIPIT_Z2 */
+			if (ev->x == KBD_PAGE_DOWN || (upcase(ev->x) == 'F' && ev->y & KBD_CTRL)) {
+#else
 			if (ev->x == KBD_PAGE_DOWN || (ev->x == ' ' && !(ev->y & KBD_ALT)) || (upcase(ev->x) == 'F' && ev->y & KBD_CTRL)) {
+#endif
 				unset_link(fd);
 				if (fd->vs->view_pos == fd->f_data->y - fd->yw + fd->f_data->hsb * G_SCROLL_BAR_WIDTH) {
 					fd->vs->orig_view_pos = fd->vs->view_pos;
@@ -1190,7 +1236,13 @@ int g_frame_ev(struct session *ses, stru
 				fd->vs->orig_view_pos = fd->vs->view_pos;
 				return 3;
 			}
+#if 1 /* ZIPIT_Z2 */
+			/* Add more conveient scroll keys for ZIPIT_Z2 */
+			if (ev->x == KBD_DEL || (upcase(ev->x) == 'N' && ev->y & KBD_CTRL) 
+			    || (ev->x == ' ' && !(ev->y & KBD_ALT))) {
+#else
 			if (ev->x == KBD_DEL || (upcase(ev->x) == 'N' && ev->y & KBD_CTRL)) {
+#endif
 				if (fd->vs->view_pos == fd->f_data->y - fd->yw + fd->f_data->hsb * G_SCROLL_BAR_WIDTH) {
 					fd->vs->orig_view_pos = fd->vs->view_pos;
 					return 0;
@@ -1234,7 +1286,19 @@ int g_frame_ev(struct session *ses, stru
 			if (ev->x == KBD_UP) {
 				return g_next_link(fd, -1);
 			}
+#if 1 /* ZIPIT_Z2 */
+			/* Allow TAB, BACKTAB to traverse links on ZIPIT_Z2 (mouse eats up,dn keys)*/
+			if ((ev->x == KBD_TAB) && (ev->y & KBD_SHIFT)) {
+				return g_next_link(fd, -1);
+			}
+			if (ev->x == KBD_TAB) {
+				return g_next_link(fd, 1);
+			}
+			/* Add more conveient sidescroll keys for ZIPIT_Z2 */
+			if ((ev->x == '[') || (ev->x == ',') || (ev->x == '<')) { 
+#else
 			if (ev->x == '[') {
+#endif
 				left:
 				if (!fd->vs->view_posx) {
 					fd->vs->orig_view_posx = fd->vs->view_posx;
@@ -1244,7 +1308,12 @@ int g_frame_ev(struct session *ses, stru
 				fd->vs->orig_view_posx = fd->vs->view_posx;
 				return 3;
 			}
+#if 1 /* ZIPIT_Z2 */
+			/* Add more conveient sidescroll keys for ZIPIT_Z2 */
+			if ((ev->x == ']') || (ev->x == '.') || (ev->x == '>')) { 
+#else
 			if (ev->x == ']') {
+#endif
 				right:
 				if (fd->vs->view_posx == fd->f_data->x - fd->xw + fd->f_data->vsb * G_SCROLL_BAR_WIDTH) {
 					fd->vs->orig_view_posx = fd->vs->view_posx;
